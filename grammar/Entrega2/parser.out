Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    comment

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM identifier semicol vars funcs MAIN body END
Rule 2     programa -> PROGRAM error semicol vars funcs MAIN body END
Rule 3     vars -> VAR var_definition
Rule 4     vars -> <empty>
Rule 5     var_definition -> id_list twopoint type semicol var_definition
Rule 6     var_definition -> id_list twopoint type semicol
Rule 7     id_list -> identifier comma id_list
Rule 8     id_list -> identifier
Rule 9     var_definition -> error twopoint type semicol var_definition
Rule 10    var_definition -> error twopoint type semicol
Rule 11    type -> INTEGER
Rule 12    type -> FLOAT
Rule 13    type -> STRING
Rule 14    funcs -> func funcs
Rule 15    funcs -> <empty>
Rule 16    func -> VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol
Rule 17    param_list -> param_list comma param
Rule 18    param_list -> param
Rule 19    param_list -> <empty>
Rule 20    param -> identifier twopoint type
Rule 21    func -> VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol
Rule 22    body -> opening_anglbrack statements closing_anglbrack
Rule 23    statements -> statements statement
Rule 24    statements -> statement
Rule 25    statements -> <empty>
Rule 26    statement -> assign
Rule 27    statement -> condition
Rule 28    statement -> cycle
Rule 29    statement -> f_call
Rule 30    statement -> print_statement
Rule 31    assign -> identifier op_assign expression semicol
Rule 32    assign -> identifier op_assign const_string semicol
Rule 33    assign -> identifier op_assign error semicol
Rule 34    expression -> exp
Rule 35    expression -> exp op_lesser_than exp
Rule 36    expression -> exp op_more_than exp
Rule 37    expression -> exp op_lessthan_equal exp
Rule 38    expression -> exp op_morethan_equal exp
Rule 39    expression -> exp op_equals exp
Rule 40    expression -> exp op_not_equal exp
Rule 41    exp -> exp op_plus term
Rule 42    exp -> exp op_minus term
Rule 43    exp -> term
Rule 44    term -> term op_mult factor
Rule 45    term -> term op_div factor
Rule 46    term -> factor
Rule 47    factor -> opening_par expression closing_par
Rule 48    factor -> op_plus identifier
Rule 49    factor -> op_plus cte
Rule 50    factor -> op_minus identifier
Rule 51    factor -> op_minus cte
Rule 52    factor -> identifier
Rule 53    factor -> cte
Rule 54    cte -> const_int
Rule 55    cte -> const_float
Rule 56    f_call -> identifier opening_par arguments closing_par semicol
Rule 57    arguments -> arguments comma expression
Rule 58    arguments -> expression
Rule 59    arguments -> <empty>
Rule 60    f_call -> identifier opening_par error closing_par semicol
Rule 61    print_statement -> PRINT opening_par print_args closing_par semicol
Rule 62    print_args -> print_args comma print_arg
Rule 63    print_args -> print_arg
Rule 64    print_arg -> expression
Rule 65    print_arg -> const_string
Rule 66    print_statement -> PRINT opening_par error closing_par semicol
Rule 67    cycle -> DO body WHILE opening_par expression closing_par semicol
Rule 68    cycle -> DO body WHILE opening_par error closing_par semicol
Rule 69    condition -> IF opening_par expression closing_par body check_else semicol
Rule 70    check_else -> ELSE body
Rule 71    check_else -> <empty>
Rule 72    condition -> IF opening_par error closing_par body check_else semicol

Terminals, with rules where they appear

DO                   : 67 68
ELSE                 : 70
END                  : 1 2
FLOAT                : 12
IF                   : 69 72
INTEGER              : 11
MAIN                 : 1 2
PRINT                : 61 66
PROGRAM              : 1 2
STRING               : 13
VAR                  : 3
VOID                 : 16 21
WHILE                : 67 68
closing_anglbrack    : 22
closing_brack        : 16 21
closing_par          : 16 21 47 56 60 61 66 67 68 69 72
comma                : 7 17 57 62
comment              : 
const_float          : 55
const_int            : 54
const_string         : 32 65
error                : 2 9 10 21 33 60 66 68 72
identifier           : 1 7 8 16 20 21 31 32 33 48 50 52 56 60
op_assign            : 31 32 33
op_div               : 45
op_equals            : 39
op_lesser_than       : 35
op_lessthan_equal    : 37
op_minus             : 42 50 51
op_more_than         : 36
op_morethan_equal    : 38
op_mult              : 44
op_not_equal         : 40
op_plus              : 41 48 49
opening_anglbrack    : 22
opening_brack        : 16 21
opening_par          : 16 21 47 56 60 61 66 67 68 69 72
semicol              : 1 2 5 6 9 10 16 21 31 32 33 56 60 61 66 67 68 69 72
twopoint             : 5 6 9 10 20

Nonterminals, with rules where they appear

arguments            : 56 57
assign               : 26
body                 : 1 2 16 21 67 68 69 70 72
check_else           : 69 72
condition            : 27
cte                  : 49 51 53
cycle                : 28
exp                  : 34 35 35 36 36 37 37 38 38 39 39 40 40 41 42
expression           : 31 47 57 58 64 67 69
f_call               : 29
factor               : 44 45 46
func                 : 14
funcs                : 1 2 14
id_list              : 5 6 7
param                : 17 18
param_list           : 16 17
print_arg            : 62 63
print_args           : 61 62
print_statement      : 30
programa             : 0
statement            : 23 24
statements           : 22 23
term                 : 41 42 43 44 45
type                 : 5 6 9 10 20
var_definition       : 3 5 9
vars                 : 1 2 16 21

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM identifier semicol vars funcs MAIN body END
    (2) programa -> . PROGRAM error semicol vars funcs MAIN body END

    PROGRAM         shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> PROGRAM . identifier semicol vars funcs MAIN body END
    (2) programa -> PROGRAM . error semicol vars funcs MAIN body END

    identifier      shift and go to state 3
    error           shift and go to state 4


state 3

    (1) programa -> PROGRAM identifier . semicol vars funcs MAIN body END

    semicol         shift and go to state 5


state 4

    (2) programa -> PROGRAM error . semicol vars funcs MAIN body END

    semicol         shift and go to state 6


state 5

    (1) programa -> PROGRAM identifier semicol . vars funcs MAIN body END
    (3) vars -> . VAR var_definition
    (4) vars -> .

    VAR             shift and go to state 8
    VOID            reduce using rule 4 (vars -> .)
    MAIN            reduce using rule 4 (vars -> .)

    vars                           shift and go to state 7

state 6

    (2) programa -> PROGRAM error semicol . vars funcs MAIN body END
    (3) vars -> . VAR var_definition
    (4) vars -> .

    VAR             shift and go to state 8
    VOID            reduce using rule 4 (vars -> .)
    MAIN            reduce using rule 4 (vars -> .)

    vars                           shift and go to state 9

state 7

    (1) programa -> PROGRAM identifier semicol vars . funcs MAIN body END
    (14) funcs -> . func funcs
    (15) funcs -> .
    (16) func -> . VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol
    (21) func -> . VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol

    MAIN            reduce using rule 15 (funcs -> .)
    VOID            shift and go to state 12

    funcs                          shift and go to state 10
    func                           shift and go to state 11

state 8

    (3) vars -> VAR . var_definition
    (5) var_definition -> . id_list twopoint type semicol var_definition
    (6) var_definition -> . id_list twopoint type semicol
    (9) var_definition -> . error twopoint type semicol var_definition
    (10) var_definition -> . error twopoint type semicol
    (7) id_list -> . identifier comma id_list
    (8) id_list -> . identifier

    error           shift and go to state 15
    identifier      shift and go to state 16

    var_definition                 shift and go to state 13
    id_list                        shift and go to state 14

state 9

    (2) programa -> PROGRAM error semicol vars . funcs MAIN body END
    (14) funcs -> . func funcs
    (15) funcs -> .
    (16) func -> . VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol
    (21) func -> . VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol

    MAIN            reduce using rule 15 (funcs -> .)
    VOID            shift and go to state 12

    funcs                          shift and go to state 17
    func                           shift and go to state 11

state 10

    (1) programa -> PROGRAM identifier semicol vars funcs . MAIN body END

    MAIN            shift and go to state 18


state 11

    (14) funcs -> func . funcs
    (14) funcs -> . func funcs
    (15) funcs -> .
    (16) func -> . VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol
    (21) func -> . VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol

    MAIN            reduce using rule 15 (funcs -> .)
    VOID            shift and go to state 12

    func                           shift and go to state 11
    funcs                          shift and go to state 19

state 12

    (16) func -> VOID . identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol
    (21) func -> VOID . identifier opening_par error closing_par opening_brack vars body closing_brack semicol

    identifier      shift and go to state 20


state 13

    (3) vars -> VAR var_definition .

    VOID            reduce using rule 3 (vars -> VAR var_definition .)
    MAIN            reduce using rule 3 (vars -> VAR var_definition .)
    opening_anglbrack reduce using rule 3 (vars -> VAR var_definition .)


state 14

    (5) var_definition -> id_list . twopoint type semicol var_definition
    (6) var_definition -> id_list . twopoint type semicol

    twopoint        shift and go to state 21


state 15

    (9) var_definition -> error . twopoint type semicol var_definition
    (10) var_definition -> error . twopoint type semicol

    twopoint        shift and go to state 22


state 16

    (7) id_list -> identifier . comma id_list
    (8) id_list -> identifier .

    comma           shift and go to state 23
    twopoint        reduce using rule 8 (id_list -> identifier .)


state 17

    (2) programa -> PROGRAM error semicol vars funcs . MAIN body END

    MAIN            shift and go to state 24


state 18

    (1) programa -> PROGRAM identifier semicol vars funcs MAIN . body END
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 25

state 19

    (14) funcs -> func funcs .

    MAIN            reduce using rule 14 (funcs -> func funcs .)


state 20

    (16) func -> VOID identifier . opening_par param_list closing_par opening_brack vars body closing_brack semicol
    (21) func -> VOID identifier . opening_par error closing_par opening_brack vars body closing_brack semicol

    opening_par     shift and go to state 27


state 21

    (5) var_definition -> id_list twopoint . type semicol var_definition
    (6) var_definition -> id_list twopoint . type semicol
    (11) type -> . INTEGER
    (12) type -> . FLOAT
    (13) type -> . STRING

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31

    type                           shift and go to state 28

state 22

    (9) var_definition -> error twopoint . type semicol var_definition
    (10) var_definition -> error twopoint . type semicol
    (11) type -> . INTEGER
    (12) type -> . FLOAT
    (13) type -> . STRING

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31

    type                           shift and go to state 32

state 23

    (7) id_list -> identifier comma . id_list
    (7) id_list -> . identifier comma id_list
    (8) id_list -> . identifier

    identifier      shift and go to state 16

    id_list                        shift and go to state 33

state 24

    (2) programa -> PROGRAM error semicol vars funcs MAIN . body END
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 34

state 25

    (1) programa -> PROGRAM identifier semicol vars funcs MAIN body . END

    END             shift and go to state 35


state 26

    (22) body -> opening_anglbrack . statements closing_anglbrack
    (23) statements -> . statements statement
    (24) statements -> . statement
    (25) statements -> .
    (26) statement -> . assign
    (27) statement -> . condition
    (28) statement -> . cycle
    (29) statement -> . f_call
    (30) statement -> . print_statement
    (31) assign -> . identifier op_assign expression semicol
    (32) assign -> . identifier op_assign const_string semicol
    (33) assign -> . identifier op_assign error semicol
    (69) condition -> . IF opening_par expression closing_par body check_else semicol
    (72) condition -> . IF opening_par error closing_par body check_else semicol
    (67) cycle -> . DO body WHILE opening_par expression closing_par semicol
    (68) cycle -> . DO body WHILE opening_par error closing_par semicol
    (56) f_call -> . identifier opening_par arguments closing_par semicol
    (60) f_call -> . identifier opening_par error closing_par semicol
    (61) print_statement -> . PRINT opening_par print_args closing_par semicol
    (66) print_statement -> . PRINT opening_par error closing_par semicol

  ! shift/reduce conflict for identifier resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    closing_anglbrack reduce using rule 25 (statements -> .)
    identifier      shift and go to state 43
    IF              shift and go to state 44
    DO              shift and go to state 45
    PRINT           shift and go to state 46

  ! identifier      [ reduce using rule 25 (statements -> .) ]
  ! IF              [ reduce using rule 25 (statements -> .) ]
  ! DO              [ reduce using rule 25 (statements -> .) ]
  ! PRINT           [ reduce using rule 25 (statements -> .) ]

    statements                     shift and go to state 36
    statement                      shift and go to state 37
    assign                         shift and go to state 38
    condition                      shift and go to state 39
    cycle                          shift and go to state 40
    f_call                         shift and go to state 41
    print_statement                shift and go to state 42

state 27

    (16) func -> VOID identifier opening_par . param_list closing_par opening_brack vars body closing_brack semicol
    (21) func -> VOID identifier opening_par . error closing_par opening_brack vars body closing_brack semicol
    (17) param_list -> . param_list comma param
    (18) param_list -> . param
    (19) param_list -> .
    (20) param -> . identifier twopoint type

    error           shift and go to state 49
    closing_par     reduce using rule 19 (param_list -> .)
    comma           reduce using rule 19 (param_list -> .)
    identifier      shift and go to state 47

    param_list                     shift and go to state 48
    param                          shift and go to state 50

state 28

    (5) var_definition -> id_list twopoint type . semicol var_definition
    (6) var_definition -> id_list twopoint type . semicol

    semicol         shift and go to state 51


state 29

    (11) type -> INTEGER .

    semicol         reduce using rule 11 (type -> INTEGER .)
    closing_par     reduce using rule 11 (type -> INTEGER .)
    comma           reduce using rule 11 (type -> INTEGER .)


state 30

    (12) type -> FLOAT .

    semicol         reduce using rule 12 (type -> FLOAT .)
    closing_par     reduce using rule 12 (type -> FLOAT .)
    comma           reduce using rule 12 (type -> FLOAT .)


state 31

    (13) type -> STRING .

    semicol         reduce using rule 13 (type -> STRING .)
    closing_par     reduce using rule 13 (type -> STRING .)
    comma           reduce using rule 13 (type -> STRING .)


state 32

    (9) var_definition -> error twopoint type . semicol var_definition
    (10) var_definition -> error twopoint type . semicol

    semicol         shift and go to state 52


state 33

    (7) id_list -> identifier comma id_list .

    twopoint        reduce using rule 7 (id_list -> identifier comma id_list .)


state 34

    (2) programa -> PROGRAM error semicol vars funcs MAIN body . END

    END             shift and go to state 53


state 35

    (1) programa -> PROGRAM identifier semicol vars funcs MAIN body END .

    $end            reduce using rule 1 (programa -> PROGRAM identifier semicol vars funcs MAIN body END .)


state 36

    (22) body -> opening_anglbrack statements . closing_anglbrack
    (23) statements -> statements . statement
    (26) statement -> . assign
    (27) statement -> . condition
    (28) statement -> . cycle
    (29) statement -> . f_call
    (30) statement -> . print_statement
    (31) assign -> . identifier op_assign expression semicol
    (32) assign -> . identifier op_assign const_string semicol
    (33) assign -> . identifier op_assign error semicol
    (69) condition -> . IF opening_par expression closing_par body check_else semicol
    (72) condition -> . IF opening_par error closing_par body check_else semicol
    (67) cycle -> . DO body WHILE opening_par expression closing_par semicol
    (68) cycle -> . DO body WHILE opening_par error closing_par semicol
    (56) f_call -> . identifier opening_par arguments closing_par semicol
    (60) f_call -> . identifier opening_par error closing_par semicol
    (61) print_statement -> . PRINT opening_par print_args closing_par semicol
    (66) print_statement -> . PRINT opening_par error closing_par semicol

    closing_anglbrack shift and go to state 54
    identifier      shift and go to state 43
    IF              shift and go to state 44
    DO              shift and go to state 45
    PRINT           shift and go to state 46

    statement                      shift and go to state 55
    assign                         shift and go to state 38
    condition                      shift and go to state 39
    cycle                          shift and go to state 40
    f_call                         shift and go to state 41
    print_statement                shift and go to state 42

state 37

    (24) statements -> statement .

    closing_anglbrack reduce using rule 24 (statements -> statement .)
    identifier      reduce using rule 24 (statements -> statement .)
    IF              reduce using rule 24 (statements -> statement .)
    DO              reduce using rule 24 (statements -> statement .)
    PRINT           reduce using rule 24 (statements -> statement .)


state 38

    (26) statement -> assign .

    closing_anglbrack reduce using rule 26 (statement -> assign .)
    identifier      reduce using rule 26 (statement -> assign .)
    IF              reduce using rule 26 (statement -> assign .)
    DO              reduce using rule 26 (statement -> assign .)
    PRINT           reduce using rule 26 (statement -> assign .)


state 39

    (27) statement -> condition .

    closing_anglbrack reduce using rule 27 (statement -> condition .)
    identifier      reduce using rule 27 (statement -> condition .)
    IF              reduce using rule 27 (statement -> condition .)
    DO              reduce using rule 27 (statement -> condition .)
    PRINT           reduce using rule 27 (statement -> condition .)


state 40

    (28) statement -> cycle .

    closing_anglbrack reduce using rule 28 (statement -> cycle .)
    identifier      reduce using rule 28 (statement -> cycle .)
    IF              reduce using rule 28 (statement -> cycle .)
    DO              reduce using rule 28 (statement -> cycle .)
    PRINT           reduce using rule 28 (statement -> cycle .)


state 41

    (29) statement -> f_call .

    closing_anglbrack reduce using rule 29 (statement -> f_call .)
    identifier      reduce using rule 29 (statement -> f_call .)
    IF              reduce using rule 29 (statement -> f_call .)
    DO              reduce using rule 29 (statement -> f_call .)
    PRINT           reduce using rule 29 (statement -> f_call .)


state 42

    (30) statement -> print_statement .

    closing_anglbrack reduce using rule 30 (statement -> print_statement .)
    identifier      reduce using rule 30 (statement -> print_statement .)
    IF              reduce using rule 30 (statement -> print_statement .)
    DO              reduce using rule 30 (statement -> print_statement .)
    PRINT           reduce using rule 30 (statement -> print_statement .)


state 43

    (31) assign -> identifier . op_assign expression semicol
    (32) assign -> identifier . op_assign const_string semicol
    (33) assign -> identifier . op_assign error semicol
    (56) f_call -> identifier . opening_par arguments closing_par semicol
    (60) f_call -> identifier . opening_par error closing_par semicol

    op_assign       shift and go to state 56
    opening_par     shift and go to state 57


state 44

    (69) condition -> IF . opening_par expression closing_par body check_else semicol
    (72) condition -> IF . opening_par error closing_par body check_else semicol

    opening_par     shift and go to state 58


state 45

    (67) cycle -> DO . body WHILE opening_par expression closing_par semicol
    (68) cycle -> DO . body WHILE opening_par error closing_par semicol
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 59

state 46

    (61) print_statement -> PRINT . opening_par print_args closing_par semicol
    (66) print_statement -> PRINT . opening_par error closing_par semicol

    opening_par     shift and go to state 60


state 47

    (20) param -> identifier . twopoint type

    twopoint        shift and go to state 61


state 48

    (16) func -> VOID identifier opening_par param_list . closing_par opening_brack vars body closing_brack semicol
    (17) param_list -> param_list . comma param

    closing_par     shift and go to state 62
    comma           shift and go to state 63


state 49

    (21) func -> VOID identifier opening_par error . closing_par opening_brack vars body closing_brack semicol

    closing_par     shift and go to state 64


state 50

    (18) param_list -> param .

    closing_par     reduce using rule 18 (param_list -> param .)
    comma           reduce using rule 18 (param_list -> param .)


state 51

    (5) var_definition -> id_list twopoint type semicol . var_definition
    (6) var_definition -> id_list twopoint type semicol .
    (5) var_definition -> . id_list twopoint type semicol var_definition
    (6) var_definition -> . id_list twopoint type semicol
    (9) var_definition -> . error twopoint type semicol var_definition
    (10) var_definition -> . error twopoint type semicol
    (7) id_list -> . identifier comma id_list
    (8) id_list -> . identifier

    VOID            reduce using rule 6 (var_definition -> id_list twopoint type semicol .)
    MAIN            reduce using rule 6 (var_definition -> id_list twopoint type semicol .)
    opening_anglbrack reduce using rule 6 (var_definition -> id_list twopoint type semicol .)
    error           shift and go to state 15
    identifier      shift and go to state 16

    id_list                        shift and go to state 14
    var_definition                 shift and go to state 65

state 52

    (9) var_definition -> error twopoint type semicol . var_definition
    (10) var_definition -> error twopoint type semicol .
    (5) var_definition -> . id_list twopoint type semicol var_definition
    (6) var_definition -> . id_list twopoint type semicol
    (9) var_definition -> . error twopoint type semicol var_definition
    (10) var_definition -> . error twopoint type semicol
    (7) id_list -> . identifier comma id_list
    (8) id_list -> . identifier

    VOID            reduce using rule 10 (var_definition -> error twopoint type semicol .)
    MAIN            reduce using rule 10 (var_definition -> error twopoint type semicol .)
    opening_anglbrack reduce using rule 10 (var_definition -> error twopoint type semicol .)
    error           shift and go to state 15
    identifier      shift and go to state 16

    var_definition                 shift and go to state 66
    id_list                        shift and go to state 14

state 53

    (2) programa -> PROGRAM error semicol vars funcs MAIN body END .

    $end            reduce using rule 2 (programa -> PROGRAM error semicol vars funcs MAIN body END .)


state 54

    (22) body -> opening_anglbrack statements closing_anglbrack .

    END             reduce using rule 22 (body -> opening_anglbrack statements closing_anglbrack .)
    WHILE           reduce using rule 22 (body -> opening_anglbrack statements closing_anglbrack .)
    ELSE            reduce using rule 22 (body -> opening_anglbrack statements closing_anglbrack .)
    semicol         reduce using rule 22 (body -> opening_anglbrack statements closing_anglbrack .)
    closing_brack   reduce using rule 22 (body -> opening_anglbrack statements closing_anglbrack .)


state 55

    (23) statements -> statements statement .

    closing_anglbrack reduce using rule 23 (statements -> statements statement .)
    identifier      reduce using rule 23 (statements -> statements statement .)
    IF              reduce using rule 23 (statements -> statements statement .)
    DO              reduce using rule 23 (statements -> statements statement .)
    PRINT           reduce using rule 23 (statements -> statements statement .)


state 56

    (31) assign -> identifier op_assign . expression semicol
    (32) assign -> identifier op_assign . const_string semicol
    (33) assign -> identifier op_assign . error semicol
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    const_string    shift and go to state 69
    error           shift and go to state 70
    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    expression                     shift and go to state 68
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 57

    (56) f_call -> identifier opening_par . arguments closing_par semicol
    (60) f_call -> identifier opening_par . error closing_par semicol
    (57) arguments -> . arguments comma expression
    (58) arguments -> . expression
    (59) arguments -> .
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    error           shift and go to state 81
    closing_par     reduce using rule 59 (arguments -> .)
    comma           reduce using rule 59 (arguments -> .)
    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    arguments                      shift and go to state 80
    expression                     shift and go to state 82
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 58

    (69) condition -> IF opening_par . expression closing_par body check_else semicol
    (72) condition -> IF opening_par . error closing_par body check_else semicol
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    error           shift and go to state 84
    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    expression                     shift and go to state 83
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 59

    (67) cycle -> DO body . WHILE opening_par expression closing_par semicol
    (68) cycle -> DO body . WHILE opening_par error closing_par semicol

    WHILE           shift and go to state 85


state 60

    (61) print_statement -> PRINT opening_par . print_args closing_par semicol
    (66) print_statement -> PRINT opening_par . error closing_par semicol
    (62) print_args -> . print_args comma print_arg
    (63) print_args -> . print_arg
    (64) print_arg -> . expression
    (65) print_arg -> . const_string
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    error           shift and go to state 87
    const_string    shift and go to state 90
    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    print_args                     shift and go to state 86
    print_arg                      shift and go to state 88
    expression                     shift and go to state 89
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 61

    (20) param -> identifier twopoint . type
    (11) type -> . INTEGER
    (12) type -> . FLOAT
    (13) type -> . STRING

    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 30
    STRING          shift and go to state 31

    type                           shift and go to state 91

state 62

    (16) func -> VOID identifier opening_par param_list closing_par . opening_brack vars body closing_brack semicol

    opening_brack   shift and go to state 92


state 63

    (17) param_list -> param_list comma . param
    (20) param -> . identifier twopoint type

    identifier      shift and go to state 47

    param                          shift and go to state 93

state 64

    (21) func -> VOID identifier opening_par error closing_par . opening_brack vars body closing_brack semicol

    opening_brack   shift and go to state 94


state 65

    (5) var_definition -> id_list twopoint type semicol var_definition .

    VOID            reduce using rule 5 (var_definition -> id_list twopoint type semicol var_definition .)
    MAIN            reduce using rule 5 (var_definition -> id_list twopoint type semicol var_definition .)
    opening_anglbrack reduce using rule 5 (var_definition -> id_list twopoint type semicol var_definition .)


state 66

    (9) var_definition -> error twopoint type semicol var_definition .

    VOID            reduce using rule 9 (var_definition -> error twopoint type semicol var_definition .)
    MAIN            reduce using rule 9 (var_definition -> error twopoint type semicol var_definition .)
    opening_anglbrack reduce using rule 9 (var_definition -> error twopoint type semicol var_definition .)


state 67

    (52) factor -> identifier .

    op_mult         reduce using rule 52 (factor -> identifier .)
    op_div          reduce using rule 52 (factor -> identifier .)
    op_lesser_than  reduce using rule 52 (factor -> identifier .)
    op_more_than    reduce using rule 52 (factor -> identifier .)
    op_lessthan_equal reduce using rule 52 (factor -> identifier .)
    op_morethan_equal reduce using rule 52 (factor -> identifier .)
    op_equals       reduce using rule 52 (factor -> identifier .)
    op_not_equal    reduce using rule 52 (factor -> identifier .)
    op_plus         reduce using rule 52 (factor -> identifier .)
    op_minus        reduce using rule 52 (factor -> identifier .)
    semicol         reduce using rule 52 (factor -> identifier .)
    closing_par     reduce using rule 52 (factor -> identifier .)
    comma           reduce using rule 52 (factor -> identifier .)


state 68

    (31) assign -> identifier op_assign expression . semicol

    semicol         shift and go to state 95


state 69

    (32) assign -> identifier op_assign const_string . semicol

    semicol         shift and go to state 96


state 70

    (33) assign -> identifier op_assign error . semicol

    semicol         shift and go to state 97


state 71

    (34) expression -> exp .
    (35) expression -> exp . op_lesser_than exp
    (36) expression -> exp . op_more_than exp
    (37) expression -> exp . op_lessthan_equal exp
    (38) expression -> exp . op_morethan_equal exp
    (39) expression -> exp . op_equals exp
    (40) expression -> exp . op_not_equal exp
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 34 (expression -> exp .)
    closing_par     reduce using rule 34 (expression -> exp .)
    comma           reduce using rule 34 (expression -> exp .)
    op_lesser_than  shift and go to state 98
    op_more_than    shift and go to state 99
    op_lessthan_equal shift and go to state 100
    op_morethan_equal shift and go to state 101
    op_equals       shift and go to state 102
    op_not_equal    shift and go to state 103
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 72

    (48) factor -> op_plus . identifier
    (49) factor -> op_plus . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    identifier      shift and go to state 106
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    cte                            shift and go to state 107

state 73

    (43) exp -> term .
    (44) term -> term . op_mult factor
    (45) term -> term . op_div factor

    op_lesser_than  reduce using rule 43 (exp -> term .)
    op_more_than    reduce using rule 43 (exp -> term .)
    op_lessthan_equal reduce using rule 43 (exp -> term .)
    op_morethan_equal reduce using rule 43 (exp -> term .)
    op_equals       reduce using rule 43 (exp -> term .)
    op_not_equal    reduce using rule 43 (exp -> term .)
    op_plus         reduce using rule 43 (exp -> term .)
    op_minus        reduce using rule 43 (exp -> term .)
    semicol         reduce using rule 43 (exp -> term .)
    closing_par     reduce using rule 43 (exp -> term .)
    comma           reduce using rule 43 (exp -> term .)
    op_mult         shift and go to state 108
    op_div          shift and go to state 109


state 74

    (50) factor -> op_minus . identifier
    (51) factor -> op_minus . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    identifier      shift and go to state 110
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    cte                            shift and go to state 111

state 75

    (46) term -> factor .

    op_mult         reduce using rule 46 (term -> factor .)
    op_div          reduce using rule 46 (term -> factor .)
    op_lesser_than  reduce using rule 46 (term -> factor .)
    op_more_than    reduce using rule 46 (term -> factor .)
    op_lessthan_equal reduce using rule 46 (term -> factor .)
    op_morethan_equal reduce using rule 46 (term -> factor .)
    op_equals       reduce using rule 46 (term -> factor .)
    op_not_equal    reduce using rule 46 (term -> factor .)
    op_plus         reduce using rule 46 (term -> factor .)
    op_minus        reduce using rule 46 (term -> factor .)
    semicol         reduce using rule 46 (term -> factor .)
    closing_par     reduce using rule 46 (term -> factor .)
    comma           reduce using rule 46 (term -> factor .)


state 76

    (47) factor -> opening_par . expression closing_par
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    expression                     shift and go to state 112
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 77

    (53) factor -> cte .

    op_mult         reduce using rule 53 (factor -> cte .)
    op_div          reduce using rule 53 (factor -> cte .)
    op_lesser_than  reduce using rule 53 (factor -> cte .)
    op_more_than    reduce using rule 53 (factor -> cte .)
    op_lessthan_equal reduce using rule 53 (factor -> cte .)
    op_morethan_equal reduce using rule 53 (factor -> cte .)
    op_equals       reduce using rule 53 (factor -> cte .)
    op_not_equal    reduce using rule 53 (factor -> cte .)
    op_plus         reduce using rule 53 (factor -> cte .)
    op_minus        reduce using rule 53 (factor -> cte .)
    semicol         reduce using rule 53 (factor -> cte .)
    closing_par     reduce using rule 53 (factor -> cte .)
    comma           reduce using rule 53 (factor -> cte .)


state 78

    (54) cte -> const_int .

    op_mult         reduce using rule 54 (cte -> const_int .)
    op_div          reduce using rule 54 (cte -> const_int .)
    op_lesser_than  reduce using rule 54 (cte -> const_int .)
    op_more_than    reduce using rule 54 (cte -> const_int .)
    op_lessthan_equal reduce using rule 54 (cte -> const_int .)
    op_morethan_equal reduce using rule 54 (cte -> const_int .)
    op_equals       reduce using rule 54 (cte -> const_int .)
    op_not_equal    reduce using rule 54 (cte -> const_int .)
    op_plus         reduce using rule 54 (cte -> const_int .)
    op_minus        reduce using rule 54 (cte -> const_int .)
    semicol         reduce using rule 54 (cte -> const_int .)
    closing_par     reduce using rule 54 (cte -> const_int .)
    comma           reduce using rule 54 (cte -> const_int .)


state 79

    (55) cte -> const_float .

    op_mult         reduce using rule 55 (cte -> const_float .)
    op_div          reduce using rule 55 (cte -> const_float .)
    op_lesser_than  reduce using rule 55 (cte -> const_float .)
    op_more_than    reduce using rule 55 (cte -> const_float .)
    op_lessthan_equal reduce using rule 55 (cte -> const_float .)
    op_morethan_equal reduce using rule 55 (cte -> const_float .)
    op_equals       reduce using rule 55 (cte -> const_float .)
    op_not_equal    reduce using rule 55 (cte -> const_float .)
    op_plus         reduce using rule 55 (cte -> const_float .)
    op_minus        reduce using rule 55 (cte -> const_float .)
    semicol         reduce using rule 55 (cte -> const_float .)
    closing_par     reduce using rule 55 (cte -> const_float .)
    comma           reduce using rule 55 (cte -> const_float .)


state 80

    (56) f_call -> identifier opening_par arguments . closing_par semicol
    (57) arguments -> arguments . comma expression

    closing_par     shift and go to state 113
    comma           shift and go to state 114


state 81

    (60) f_call -> identifier opening_par error . closing_par semicol

    closing_par     shift and go to state 115


state 82

    (58) arguments -> expression .

    closing_par     reduce using rule 58 (arguments -> expression .)
    comma           reduce using rule 58 (arguments -> expression .)


state 83

    (69) condition -> IF opening_par expression . closing_par body check_else semicol

    closing_par     shift and go to state 116


state 84

    (72) condition -> IF opening_par error . closing_par body check_else semicol

    closing_par     shift and go to state 117


state 85

    (67) cycle -> DO body WHILE . opening_par expression closing_par semicol
    (68) cycle -> DO body WHILE . opening_par error closing_par semicol

    opening_par     shift and go to state 118


state 86

    (61) print_statement -> PRINT opening_par print_args . closing_par semicol
    (62) print_args -> print_args . comma print_arg

    closing_par     shift and go to state 119
    comma           shift and go to state 120


state 87

    (66) print_statement -> PRINT opening_par error . closing_par semicol

    closing_par     shift and go to state 121


state 88

    (63) print_args -> print_arg .

    closing_par     reduce using rule 63 (print_args -> print_arg .)
    comma           reduce using rule 63 (print_args -> print_arg .)


state 89

    (64) print_arg -> expression .

    closing_par     reduce using rule 64 (print_arg -> expression .)
    comma           reduce using rule 64 (print_arg -> expression .)


state 90

    (65) print_arg -> const_string .

    closing_par     reduce using rule 65 (print_arg -> const_string .)
    comma           reduce using rule 65 (print_arg -> const_string .)


state 91

    (20) param -> identifier twopoint type .

    closing_par     reduce using rule 20 (param -> identifier twopoint type .)
    comma           reduce using rule 20 (param -> identifier twopoint type .)


state 92

    (16) func -> VOID identifier opening_par param_list closing_par opening_brack . vars body closing_brack semicol
    (3) vars -> . VAR var_definition
    (4) vars -> .

    VAR             shift and go to state 8
    opening_anglbrack reduce using rule 4 (vars -> .)

    vars                           shift and go to state 122

state 93

    (17) param_list -> param_list comma param .

    closing_par     reduce using rule 17 (param_list -> param_list comma param .)
    comma           reduce using rule 17 (param_list -> param_list comma param .)


state 94

    (21) func -> VOID identifier opening_par error closing_par opening_brack . vars body closing_brack semicol
    (3) vars -> . VAR var_definition
    (4) vars -> .

    VAR             shift and go to state 8
    opening_anglbrack reduce using rule 4 (vars -> .)

    vars                           shift and go to state 123

state 95

    (31) assign -> identifier op_assign expression semicol .

    closing_anglbrack reduce using rule 31 (assign -> identifier op_assign expression semicol .)
    identifier      reduce using rule 31 (assign -> identifier op_assign expression semicol .)
    IF              reduce using rule 31 (assign -> identifier op_assign expression semicol .)
    DO              reduce using rule 31 (assign -> identifier op_assign expression semicol .)
    PRINT           reduce using rule 31 (assign -> identifier op_assign expression semicol .)


state 96

    (32) assign -> identifier op_assign const_string semicol .

    closing_anglbrack reduce using rule 32 (assign -> identifier op_assign const_string semicol .)
    identifier      reduce using rule 32 (assign -> identifier op_assign const_string semicol .)
    IF              reduce using rule 32 (assign -> identifier op_assign const_string semicol .)
    DO              reduce using rule 32 (assign -> identifier op_assign const_string semicol .)
    PRINT           reduce using rule 32 (assign -> identifier op_assign const_string semicol .)


state 97

    (33) assign -> identifier op_assign error semicol .

    closing_anglbrack reduce using rule 33 (assign -> identifier op_assign error semicol .)
    identifier      reduce using rule 33 (assign -> identifier op_assign error semicol .)
    IF              reduce using rule 33 (assign -> identifier op_assign error semicol .)
    DO              reduce using rule 33 (assign -> identifier op_assign error semicol .)
    PRINT           reduce using rule 33 (assign -> identifier op_assign error semicol .)


state 98

    (35) expression -> exp op_lesser_than . exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    exp                            shift and go to state 124
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 99

    (36) expression -> exp op_more_than . exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    exp                            shift and go to state 125
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 100

    (37) expression -> exp op_lessthan_equal . exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    exp                            shift and go to state 126
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 101

    (38) expression -> exp op_morethan_equal . exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    exp                            shift and go to state 127
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 102

    (39) expression -> exp op_equals . exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    exp                            shift and go to state 128
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 103

    (40) expression -> exp op_not_equal . exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    exp                            shift and go to state 129
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 104

    (41) exp -> exp op_plus . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    term                           shift and go to state 130
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 105

    (42) exp -> exp op_minus . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    term                           shift and go to state 131
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 106

    (48) factor -> op_plus identifier .

    op_mult         reduce using rule 48 (factor -> op_plus identifier .)
    op_div          reduce using rule 48 (factor -> op_plus identifier .)
    op_lesser_than  reduce using rule 48 (factor -> op_plus identifier .)
    op_more_than    reduce using rule 48 (factor -> op_plus identifier .)
    op_lessthan_equal reduce using rule 48 (factor -> op_plus identifier .)
    op_morethan_equal reduce using rule 48 (factor -> op_plus identifier .)
    op_equals       reduce using rule 48 (factor -> op_plus identifier .)
    op_not_equal    reduce using rule 48 (factor -> op_plus identifier .)
    op_plus         reduce using rule 48 (factor -> op_plus identifier .)
    op_minus        reduce using rule 48 (factor -> op_plus identifier .)
    semicol         reduce using rule 48 (factor -> op_plus identifier .)
    closing_par     reduce using rule 48 (factor -> op_plus identifier .)
    comma           reduce using rule 48 (factor -> op_plus identifier .)


state 107

    (49) factor -> op_plus cte .

    op_mult         reduce using rule 49 (factor -> op_plus cte .)
    op_div          reduce using rule 49 (factor -> op_plus cte .)
    op_lesser_than  reduce using rule 49 (factor -> op_plus cte .)
    op_more_than    reduce using rule 49 (factor -> op_plus cte .)
    op_lessthan_equal reduce using rule 49 (factor -> op_plus cte .)
    op_morethan_equal reduce using rule 49 (factor -> op_plus cte .)
    op_equals       reduce using rule 49 (factor -> op_plus cte .)
    op_not_equal    reduce using rule 49 (factor -> op_plus cte .)
    op_plus         reduce using rule 49 (factor -> op_plus cte .)
    op_minus        reduce using rule 49 (factor -> op_plus cte .)
    semicol         reduce using rule 49 (factor -> op_plus cte .)
    closing_par     reduce using rule 49 (factor -> op_plus cte .)
    comma           reduce using rule 49 (factor -> op_plus cte .)


state 108

    (44) term -> term op_mult . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    factor                         shift and go to state 132
    cte                            shift and go to state 77

state 109

    (45) term -> term op_div . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    factor                         shift and go to state 133
    cte                            shift and go to state 77

state 110

    (50) factor -> op_minus identifier .

    op_mult         reduce using rule 50 (factor -> op_minus identifier .)
    op_div          reduce using rule 50 (factor -> op_minus identifier .)
    op_lesser_than  reduce using rule 50 (factor -> op_minus identifier .)
    op_more_than    reduce using rule 50 (factor -> op_minus identifier .)
    op_lessthan_equal reduce using rule 50 (factor -> op_minus identifier .)
    op_morethan_equal reduce using rule 50 (factor -> op_minus identifier .)
    op_equals       reduce using rule 50 (factor -> op_minus identifier .)
    op_not_equal    reduce using rule 50 (factor -> op_minus identifier .)
    op_plus         reduce using rule 50 (factor -> op_minus identifier .)
    op_minus        reduce using rule 50 (factor -> op_minus identifier .)
    semicol         reduce using rule 50 (factor -> op_minus identifier .)
    closing_par     reduce using rule 50 (factor -> op_minus identifier .)
    comma           reduce using rule 50 (factor -> op_minus identifier .)


state 111

    (51) factor -> op_minus cte .

    op_mult         reduce using rule 51 (factor -> op_minus cte .)
    op_div          reduce using rule 51 (factor -> op_minus cte .)
    op_lesser_than  reduce using rule 51 (factor -> op_minus cte .)
    op_more_than    reduce using rule 51 (factor -> op_minus cte .)
    op_lessthan_equal reduce using rule 51 (factor -> op_minus cte .)
    op_morethan_equal reduce using rule 51 (factor -> op_minus cte .)
    op_equals       reduce using rule 51 (factor -> op_minus cte .)
    op_not_equal    reduce using rule 51 (factor -> op_minus cte .)
    op_plus         reduce using rule 51 (factor -> op_minus cte .)
    op_minus        reduce using rule 51 (factor -> op_minus cte .)
    semicol         reduce using rule 51 (factor -> op_minus cte .)
    closing_par     reduce using rule 51 (factor -> op_minus cte .)
    comma           reduce using rule 51 (factor -> op_minus cte .)


state 112

    (47) factor -> opening_par expression . closing_par

    closing_par     shift and go to state 134


state 113

    (56) f_call -> identifier opening_par arguments closing_par . semicol

    semicol         shift and go to state 135


state 114

    (57) arguments -> arguments comma . expression
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    expression                     shift and go to state 136
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 115

    (60) f_call -> identifier opening_par error closing_par . semicol

    semicol         shift and go to state 137


state 116

    (69) condition -> IF opening_par expression closing_par . body check_else semicol
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 138

state 117

    (72) condition -> IF opening_par error closing_par . body check_else semicol
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 139

state 118

    (67) cycle -> DO body WHILE opening_par . expression closing_par semicol
    (68) cycle -> DO body WHILE opening_par . error closing_par semicol
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    error           shift and go to state 141
    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    expression                     shift and go to state 140
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 119

    (61) print_statement -> PRINT opening_par print_args closing_par . semicol

    semicol         shift and go to state 142


state 120

    (62) print_args -> print_args comma . print_arg
    (64) print_arg -> . expression
    (65) print_arg -> . const_string
    (34) expression -> . exp
    (35) expression -> . exp op_lesser_than exp
    (36) expression -> . exp op_more_than exp
    (37) expression -> . exp op_lessthan_equal exp
    (38) expression -> . exp op_morethan_equal exp
    (39) expression -> . exp op_equals exp
    (40) expression -> . exp op_not_equal exp
    (41) exp -> . exp op_plus term
    (42) exp -> . exp op_minus term
    (43) exp -> . term
    (44) term -> . term op_mult factor
    (45) term -> . term op_div factor
    (46) term -> . factor
    (47) factor -> . opening_par expression closing_par
    (48) factor -> . op_plus identifier
    (49) factor -> . op_plus cte
    (50) factor -> . op_minus identifier
    (51) factor -> . op_minus cte
    (52) factor -> . identifier
    (53) factor -> . cte
    (54) cte -> . const_int
    (55) cte -> . const_float

    const_string    shift and go to state 90
    opening_par     shift and go to state 76
    op_plus         shift and go to state 72
    op_minus        shift and go to state 74
    identifier      shift and go to state 67
    const_int       shift and go to state 78
    const_float     shift and go to state 79

    print_arg                      shift and go to state 143
    expression                     shift and go to state 89
    exp                            shift and go to state 71
    term                           shift and go to state 73
    factor                         shift and go to state 75
    cte                            shift and go to state 77

state 121

    (66) print_statement -> PRINT opening_par error closing_par . semicol

    semicol         shift and go to state 144


state 122

    (16) func -> VOID identifier opening_par param_list closing_par opening_brack vars . body closing_brack semicol
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 145

state 123

    (21) func -> VOID identifier opening_par error closing_par opening_brack vars . body closing_brack semicol
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 146

state 124

    (35) expression -> exp op_lesser_than exp .
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 35 (expression -> exp op_lesser_than exp .)
    closing_par     reduce using rule 35 (expression -> exp op_lesser_than exp .)
    comma           reduce using rule 35 (expression -> exp op_lesser_than exp .)
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 125

    (36) expression -> exp op_more_than exp .
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 36 (expression -> exp op_more_than exp .)
    closing_par     reduce using rule 36 (expression -> exp op_more_than exp .)
    comma           reduce using rule 36 (expression -> exp op_more_than exp .)
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 126

    (37) expression -> exp op_lessthan_equal exp .
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 37 (expression -> exp op_lessthan_equal exp .)
    closing_par     reduce using rule 37 (expression -> exp op_lessthan_equal exp .)
    comma           reduce using rule 37 (expression -> exp op_lessthan_equal exp .)
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 127

    (38) expression -> exp op_morethan_equal exp .
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 38 (expression -> exp op_morethan_equal exp .)
    closing_par     reduce using rule 38 (expression -> exp op_morethan_equal exp .)
    comma           reduce using rule 38 (expression -> exp op_morethan_equal exp .)
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 128

    (39) expression -> exp op_equals exp .
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 39 (expression -> exp op_equals exp .)
    closing_par     reduce using rule 39 (expression -> exp op_equals exp .)
    comma           reduce using rule 39 (expression -> exp op_equals exp .)
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 129

    (40) expression -> exp op_not_equal exp .
    (41) exp -> exp . op_plus term
    (42) exp -> exp . op_minus term

    semicol         reduce using rule 40 (expression -> exp op_not_equal exp .)
    closing_par     reduce using rule 40 (expression -> exp op_not_equal exp .)
    comma           reduce using rule 40 (expression -> exp op_not_equal exp .)
    op_plus         shift and go to state 104
    op_minus        shift and go to state 105


state 130

    (41) exp -> exp op_plus term .
    (44) term -> term . op_mult factor
    (45) term -> term . op_div factor

    op_lesser_than  reduce using rule 41 (exp -> exp op_plus term .)
    op_more_than    reduce using rule 41 (exp -> exp op_plus term .)
    op_lessthan_equal reduce using rule 41 (exp -> exp op_plus term .)
    op_morethan_equal reduce using rule 41 (exp -> exp op_plus term .)
    op_equals       reduce using rule 41 (exp -> exp op_plus term .)
    op_not_equal    reduce using rule 41 (exp -> exp op_plus term .)
    op_plus         reduce using rule 41 (exp -> exp op_plus term .)
    op_minus        reduce using rule 41 (exp -> exp op_plus term .)
    semicol         reduce using rule 41 (exp -> exp op_plus term .)
    closing_par     reduce using rule 41 (exp -> exp op_plus term .)
    comma           reduce using rule 41 (exp -> exp op_plus term .)
    op_mult         shift and go to state 108
    op_div          shift and go to state 109


state 131

    (42) exp -> exp op_minus term .
    (44) term -> term . op_mult factor
    (45) term -> term . op_div factor

    op_lesser_than  reduce using rule 42 (exp -> exp op_minus term .)
    op_more_than    reduce using rule 42 (exp -> exp op_minus term .)
    op_lessthan_equal reduce using rule 42 (exp -> exp op_minus term .)
    op_morethan_equal reduce using rule 42 (exp -> exp op_minus term .)
    op_equals       reduce using rule 42 (exp -> exp op_minus term .)
    op_not_equal    reduce using rule 42 (exp -> exp op_minus term .)
    op_plus         reduce using rule 42 (exp -> exp op_minus term .)
    op_minus        reduce using rule 42 (exp -> exp op_minus term .)
    semicol         reduce using rule 42 (exp -> exp op_minus term .)
    closing_par     reduce using rule 42 (exp -> exp op_minus term .)
    comma           reduce using rule 42 (exp -> exp op_minus term .)
    op_mult         shift and go to state 108
    op_div          shift and go to state 109


state 132

    (44) term -> term op_mult factor .

    op_mult         reduce using rule 44 (term -> term op_mult factor .)
    op_div          reduce using rule 44 (term -> term op_mult factor .)
    op_lesser_than  reduce using rule 44 (term -> term op_mult factor .)
    op_more_than    reduce using rule 44 (term -> term op_mult factor .)
    op_lessthan_equal reduce using rule 44 (term -> term op_mult factor .)
    op_morethan_equal reduce using rule 44 (term -> term op_mult factor .)
    op_equals       reduce using rule 44 (term -> term op_mult factor .)
    op_not_equal    reduce using rule 44 (term -> term op_mult factor .)
    op_plus         reduce using rule 44 (term -> term op_mult factor .)
    op_minus        reduce using rule 44 (term -> term op_mult factor .)
    semicol         reduce using rule 44 (term -> term op_mult factor .)
    closing_par     reduce using rule 44 (term -> term op_mult factor .)
    comma           reduce using rule 44 (term -> term op_mult factor .)


state 133

    (45) term -> term op_div factor .

    op_mult         reduce using rule 45 (term -> term op_div factor .)
    op_div          reduce using rule 45 (term -> term op_div factor .)
    op_lesser_than  reduce using rule 45 (term -> term op_div factor .)
    op_more_than    reduce using rule 45 (term -> term op_div factor .)
    op_lessthan_equal reduce using rule 45 (term -> term op_div factor .)
    op_morethan_equal reduce using rule 45 (term -> term op_div factor .)
    op_equals       reduce using rule 45 (term -> term op_div factor .)
    op_not_equal    reduce using rule 45 (term -> term op_div factor .)
    op_plus         reduce using rule 45 (term -> term op_div factor .)
    op_minus        reduce using rule 45 (term -> term op_div factor .)
    semicol         reduce using rule 45 (term -> term op_div factor .)
    closing_par     reduce using rule 45 (term -> term op_div factor .)
    comma           reduce using rule 45 (term -> term op_div factor .)


state 134

    (47) factor -> opening_par expression closing_par .

    op_mult         reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_div          reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_lesser_than  reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_more_than    reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_lessthan_equal reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_morethan_equal reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_equals       reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_not_equal    reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_plus         reduce using rule 47 (factor -> opening_par expression closing_par .)
    op_minus        reduce using rule 47 (factor -> opening_par expression closing_par .)
    semicol         reduce using rule 47 (factor -> opening_par expression closing_par .)
    closing_par     reduce using rule 47 (factor -> opening_par expression closing_par .)
    comma           reduce using rule 47 (factor -> opening_par expression closing_par .)


state 135

    (56) f_call -> identifier opening_par arguments closing_par semicol .

    closing_anglbrack reduce using rule 56 (f_call -> identifier opening_par arguments closing_par semicol .)
    identifier      reduce using rule 56 (f_call -> identifier opening_par arguments closing_par semicol .)
    IF              reduce using rule 56 (f_call -> identifier opening_par arguments closing_par semicol .)
    DO              reduce using rule 56 (f_call -> identifier opening_par arguments closing_par semicol .)
    PRINT           reduce using rule 56 (f_call -> identifier opening_par arguments closing_par semicol .)


state 136

    (57) arguments -> arguments comma expression .

    closing_par     reduce using rule 57 (arguments -> arguments comma expression .)
    comma           reduce using rule 57 (arguments -> arguments comma expression .)


state 137

    (60) f_call -> identifier opening_par error closing_par semicol .

    closing_anglbrack reduce using rule 60 (f_call -> identifier opening_par error closing_par semicol .)
    identifier      reduce using rule 60 (f_call -> identifier opening_par error closing_par semicol .)
    IF              reduce using rule 60 (f_call -> identifier opening_par error closing_par semicol .)
    DO              reduce using rule 60 (f_call -> identifier opening_par error closing_par semicol .)
    PRINT           reduce using rule 60 (f_call -> identifier opening_par error closing_par semicol .)


state 138

    (69) condition -> IF opening_par expression closing_par body . check_else semicol
    (70) check_else -> . ELSE body
    (71) check_else -> .

    ELSE            shift and go to state 148
    semicol         reduce using rule 71 (check_else -> .)

    check_else                     shift and go to state 147

state 139

    (72) condition -> IF opening_par error closing_par body . check_else semicol
    (70) check_else -> . ELSE body
    (71) check_else -> .

    ELSE            shift and go to state 148
    semicol         reduce using rule 71 (check_else -> .)

    check_else                     shift and go to state 149

state 140

    (67) cycle -> DO body WHILE opening_par expression . closing_par semicol

    closing_par     shift and go to state 150


state 141

    (68) cycle -> DO body WHILE opening_par error . closing_par semicol

    closing_par     shift and go to state 151


state 142

    (61) print_statement -> PRINT opening_par print_args closing_par semicol .

    closing_anglbrack reduce using rule 61 (print_statement -> PRINT opening_par print_args closing_par semicol .)
    identifier      reduce using rule 61 (print_statement -> PRINT opening_par print_args closing_par semicol .)
    IF              reduce using rule 61 (print_statement -> PRINT opening_par print_args closing_par semicol .)
    DO              reduce using rule 61 (print_statement -> PRINT opening_par print_args closing_par semicol .)
    PRINT           reduce using rule 61 (print_statement -> PRINT opening_par print_args closing_par semicol .)


state 143

    (62) print_args -> print_args comma print_arg .

    closing_par     reduce using rule 62 (print_args -> print_args comma print_arg .)
    comma           reduce using rule 62 (print_args -> print_args comma print_arg .)


state 144

    (66) print_statement -> PRINT opening_par error closing_par semicol .

    closing_anglbrack reduce using rule 66 (print_statement -> PRINT opening_par error closing_par semicol .)
    identifier      reduce using rule 66 (print_statement -> PRINT opening_par error closing_par semicol .)
    IF              reduce using rule 66 (print_statement -> PRINT opening_par error closing_par semicol .)
    DO              reduce using rule 66 (print_statement -> PRINT opening_par error closing_par semicol .)
    PRINT           reduce using rule 66 (print_statement -> PRINT opening_par error closing_par semicol .)


state 145

    (16) func -> VOID identifier opening_par param_list closing_par opening_brack vars body . closing_brack semicol

    closing_brack   shift and go to state 152


state 146

    (21) func -> VOID identifier opening_par error closing_par opening_brack vars body . closing_brack semicol

    closing_brack   shift and go to state 153


state 147

    (69) condition -> IF opening_par expression closing_par body check_else . semicol

    semicol         shift and go to state 154


state 148

    (70) check_else -> ELSE . body
    (22) body -> . opening_anglbrack statements closing_anglbrack

    opening_anglbrack shift and go to state 26

    body                           shift and go to state 155

state 149

    (72) condition -> IF opening_par error closing_par body check_else . semicol

    semicol         shift and go to state 156


state 150

    (67) cycle -> DO body WHILE opening_par expression closing_par . semicol

    semicol         shift and go to state 157


state 151

    (68) cycle -> DO body WHILE opening_par error closing_par . semicol

    semicol         shift and go to state 158


state 152

    (16) func -> VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack . semicol

    semicol         shift and go to state 159


state 153

    (21) func -> VOID identifier opening_par error closing_par opening_brack vars body closing_brack . semicol

    semicol         shift and go to state 160


state 154

    (69) condition -> IF opening_par expression closing_par body check_else semicol .

    closing_anglbrack reduce using rule 69 (condition -> IF opening_par expression closing_par body check_else semicol .)
    identifier      reduce using rule 69 (condition -> IF opening_par expression closing_par body check_else semicol .)
    IF              reduce using rule 69 (condition -> IF opening_par expression closing_par body check_else semicol .)
    DO              reduce using rule 69 (condition -> IF opening_par expression closing_par body check_else semicol .)
    PRINT           reduce using rule 69 (condition -> IF opening_par expression closing_par body check_else semicol .)


state 155

    (70) check_else -> ELSE body .

    semicol         reduce using rule 70 (check_else -> ELSE body .)


state 156

    (72) condition -> IF opening_par error closing_par body check_else semicol .

    closing_anglbrack reduce using rule 72 (condition -> IF opening_par error closing_par body check_else semicol .)
    identifier      reduce using rule 72 (condition -> IF opening_par error closing_par body check_else semicol .)
    IF              reduce using rule 72 (condition -> IF opening_par error closing_par body check_else semicol .)
    DO              reduce using rule 72 (condition -> IF opening_par error closing_par body check_else semicol .)
    PRINT           reduce using rule 72 (condition -> IF opening_par error closing_par body check_else semicol .)


state 157

    (67) cycle -> DO body WHILE opening_par expression closing_par semicol .

    closing_anglbrack reduce using rule 67 (cycle -> DO body WHILE opening_par expression closing_par semicol .)
    identifier      reduce using rule 67 (cycle -> DO body WHILE opening_par expression closing_par semicol .)
    IF              reduce using rule 67 (cycle -> DO body WHILE opening_par expression closing_par semicol .)
    DO              reduce using rule 67 (cycle -> DO body WHILE opening_par expression closing_par semicol .)
    PRINT           reduce using rule 67 (cycle -> DO body WHILE opening_par expression closing_par semicol .)


state 158

    (68) cycle -> DO body WHILE opening_par error closing_par semicol .

    closing_anglbrack reduce using rule 68 (cycle -> DO body WHILE opening_par error closing_par semicol .)
    identifier      reduce using rule 68 (cycle -> DO body WHILE opening_par error closing_par semicol .)
    IF              reduce using rule 68 (cycle -> DO body WHILE opening_par error closing_par semicol .)
    DO              reduce using rule 68 (cycle -> DO body WHILE opening_par error closing_par semicol .)
    PRINT           reduce using rule 68 (cycle -> DO body WHILE opening_par error closing_par semicol .)


state 159

    (16) func -> VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol .

    VOID            reduce using rule 16 (func -> VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol .)
    MAIN            reduce using rule 16 (func -> VOID identifier opening_par param_list closing_par opening_brack vars body closing_brack semicol .)


state 160

    (21) func -> VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol .

    VOID            reduce using rule 21 (func -> VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol .)
    MAIN            reduce using rule 21 (func -> VOID identifier opening_par error closing_par opening_brack vars body closing_brack semicol .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for identifier in state 26 resolved as shift
WARNING: shift/reduce conflict for IF in state 26 resolved as shift
WARNING: shift/reduce conflict for DO in state 26 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 26 resolved as shift
